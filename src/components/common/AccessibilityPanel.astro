---
// Main accessibility settings panel
import { DEFAULT_SETTINGS } from './AccessibilitySettings';

// Server-side: use default settings for initial state (client-side will load from localStorage)
const settings = DEFAULT_SETTINGS;
---

<!-- Panel -->
<aside
  id="accessibility-panel"
  class="accessibility-panel"
  role="dialog"
  aria-modal="true"
  aria-label="Accessibility Settings"
>
  <div class="accessibility-panel-header">
    <h2 class="accessibility-panel-title">Accessibility Settings</h2>
    <button
      id="accessibility-close"
      type="button"
      class="accessibility-panel-close"
      aria-label="Close accessibility settings"
    >
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
      </svg>
    </button>
  </div>

  <div class="accessibility-panel-content">
    <!-- Font Selection -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Font</h3>
      <div class="accessibility-radio-group" role="radiogroup" aria-label="Font selection">
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="font"
            value="sylexiad"
            checked={settings.font === 'sylexiad'}
            class="accessibility-radio"
          />
          <span class="font-preview font-preview-sylexiad">Sylexiad Sans</span>
        </label>
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="font"
            value="opendyslexic"
            checked={settings.font === 'opendyslexic'}
            class="accessibility-radio"
          />
          <span class="font-preview font-preview-opendyslexic">OpenDyslexic</span>
        </label>
        <label class="accessibility-radio-label">
          <input type="radio" name="font" value="fast" checked={settings.font === 'fast'} class="accessibility-radio" />
          <span class="font-preview font-preview-fast">Fast Sans</span>
        </label>
      </div>
    </section>

    <!-- Theme Selection -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Theme</h3>
      <div class="accessibility-radio-group" role="radiogroup" aria-label="Theme selection">
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="theme"
            value="light"
            checked={settings.theme === 'light'}
            class="accessibility-radio"
          />
          <span>Light</span>
        </label>
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="theme"
            value="dark"
            checked={settings.theme === 'dark'}
            class="accessibility-radio"
          />
          <span>Dark</span>
        </label>
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="theme"
            value="system"
            checked={settings.theme === 'system'}
            class="accessibility-radio"
          />
          <span>System</span>
        </label>
      </div>
    </section>

    <!-- Text Size -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Text Size</h3>
      <div class="accessibility-button-group" role="group" aria-label="Text size selection">
        <button
          type="button"
          data-text-size="xs"
          class="accessibility-size-btn"
          aria-pressed={settings.textSize === 'xs'}
          aria-label="Extra Small"
        >
          <span style="font-size: 0.75rem;">A-</span>
        </button>
        <button
          type="button"
          data-text-size="sm"
          class="accessibility-size-btn"
          aria-pressed={settings.textSize === 'sm'}
          aria-label="Small"
        >
          <span style="font-size: 0.875rem;">A-</span>
        </button>
        <button
          type="button"
          data-text-size="base"
          class="accessibility-size-btn active"
          aria-pressed={settings.textSize === 'base'}
          aria-label="Normal"
        >
          <span style="font-size: 1rem;">A</span>
        </button>
        <button
          type="button"
          data-text-size="lg"
          class="accessibility-size-btn"
          aria-pressed={settings.textSize === 'lg'}
          aria-label="Large"
        >
          <span style="font-size: 1.125rem;">A+</span>
        </button>
        <button
          type="button"
          data-text-size="xl"
          class="accessibility-size-btn"
          aria-pressed={settings.textSize === 'xl'}
          aria-label="Extra Large"
        >
          <span style="font-size: 1.25rem;">A+</span>
        </button>
      </div>
      <p class="accessibility-size-label">Current: <span id="text-size-label">Normal</span></p>
    </section>

    <!-- Line Height (Placeholder) -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Line Height</h3>
      <div class="accessibility-radio-group" role="radiogroup" aria-label="Line height selection">
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="lineHeight"
            value="compact"
            checked={settings.lineHeight === 'compact'}
            class="accessibility-radio"
          />
          <span>Compact</span>
        </label>
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="lineHeight"
            value="normal"
            checked={settings.lineHeight === 'normal'}
            class="accessibility-radio"
          />
          <span>Normal</span>
        </label>
        <label class="accessibility-radio-label">
          <input
            type="radio"
            name="lineHeight"
            value="relaxed"
            checked={settings.lineHeight === 'relaxed'}
            class="accessibility-radio"
          />
          <span>Relaxed</span>
        </label>
      </div>
    </section>

    <!-- Reading Ruler (Placeholder) -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Reading Ruler</h3>
      <label class="accessibility-toggle-label">
        <input type="checkbox" id="reading-ruler" checked={settings.readingRuler} class="accessibility-toggle" />
        <span class="accessibility-toggle-slider"></span>
        <span class="accessibility-toggle-text">Highlight current line</span>
      </label>
    </section>

    <!-- Text-to-Speech -->
    <section class="accessibility-section">
      <h3 class="accessibility-section-title">Text-to-Speech</h3>
      <button type="button" data-tts-toggle class="accessibility-tts-btn" aria-label="Listen to this page">
        <!-- Loading spinner (hidden by default) -->
        <svg class="tts-loading-spinner" style="display: none;" viewBox="0 0 24 24" fill="none">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" stroke-opacity="0.25"></circle>
          <path fill="currentColor" d="M12 2a10 10 0 0 1 10 10h-4a6 6 0 0 0-6-6V2z" opacity="0.75">
            <animateTransform
              attributeName="transform"
              type="rotate"
              from="0 12 12"
              to="360 12 12"
              dur="1s"
              repeatCount="indefinite"></animateTransform>
          </path>
        </svg>
        <!-- Volume icon (shown by default) -->
        <svg class="tts-btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"
          ></path>
        </svg>
        <span>Listen to This Page</span>
      </button>
    </section>

    <!-- Reset Button -->
    <section class="accessibility-section">
      <button id="reset-settings" type="button" class="accessibility-reset-btn"> Reset to Defaults </button>
    </section>
  </div>
</aside>

<!-- Backdrop -->
<div id="accessibility-backdrop" class="accessibility-backdrop" aria-hidden="true"></div>

<style>
  /* Backdrop */
  .accessibility-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    opacity: 0;
    visibility: hidden;
    transition:
      opacity 300ms ease,
      visibility 300ms ease;
    z-index: 999;
  }

  .accessibility-panel.open ~ .accessibility-backdrop {
    opacity: 1;
    visibility: visible;
  }

  /* Panel */
  .accessibility-panel {
    position: fixed;
    top: 0;
    right: 0;
    width: 360px;
    max-width: 100vw;
    height: 100vh;
    background: var(--aw-color-bg-page);
    box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
    transform: translateX(100%);
    transition: transform 300ms ease;
    z-index: 1000;
    overflow-y: auto;
  }

  .accessibility-panel.open {
    transform: translateX(0);
  }

  /* Mobile: slide up from bottom */
  @media (max-width: 767px) {
    .accessibility-panel {
      top: auto;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      height: 80vh;
      max-height: 600px;
      transform: translateY(100%);
    }

    .accessibility-panel.open {
      transform: translateY(0);
    }
  }

  /* Header */
  .accessibility-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem;
    border-bottom: 1px solid var(--aw-color-border);
    position: sticky;
    top: 0;
    background: var(--aw-color-bg-page);
    z-index: 1;
  }

  .accessibility-panel-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
  }

  .accessibility-panel-close {
    padding: 0.5rem;
    border-radius: 0.375rem;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--aw-color-text-muted);
    transition:
      background-color 200ms,
      color 200ms;
  }

  .accessibility-panel-close:hover {
    background: var(--aw-color-bg-hover);
    color: var(--aw-color-text);
  }

  /* Content */
  .accessibility-panel-content {
    padding: 1.5rem;
  }

  .accessibility-section {
    margin-bottom: 2rem;
  }

  .accessibility-section:last-child {
    margin-bottom: 0;
  }

  .accessibility-section-title {
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--aw-color-text-muted);
    margin: 0 0 0.75rem 0;
  }

  /* Radio Groups */
  .accessibility-radio-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .accessibility-radio-label {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: background-color 200ms;
  }

  .accessibility-radio-label:hover {
    background: var(--aw-color-bg-hover);
  }

  .accessibility-radio {
    margin-right: 0.75rem;
    width: 1.25rem;
    height: 1.25rem;
    cursor: pointer;
  }

  /* Font preview styles - fonts loaded asynchronously via DeferredFontLoader */
  .font-preview-sylexiad {
    font-family: 'Sylexiad Sans Medium', sans-serif;
  }

  .font-preview-opendyslexic {
    font-family: 'OpenDyslexic3', sans-serif;
  }

  .font-preview-fast {
    font-family: 'Fast Sans', sans-serif;
  }

  /* Button Groups */
  .accessibility-button-group {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .accessibility-size-btn {
    flex: 1;
    padding: 0.75rem;
    border: 1px solid var(--aw-color-border);
    border-radius: 0.375rem;
    background: transparent;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 500;
    transition: all 200ms;
  }

  .accessibility-size-btn:hover {
    background: var(--aw-color-bg-hover);
  }

  .accessibility-size-btn.active,
  .accessibility-size-btn[aria-pressed='true'] {
    background: var(--aw-color-primary);
    color: white;
    border-color: var(--aw-color-primary);
  }

  .accessibility-size-label {
    color: var(--aw-color-text-muted);
    margin: 0;
  }

  /* Toggle Switch */
  .accessibility-toggle-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 0.75rem;
    border-radius: 0.5rem;
    transition: background-color 200ms;
  }

  .accessibility-toggle-label:hover {
    background: var(--aw-color-bg-hover);
  }

  .accessibility-toggle {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  .accessibility-toggle-slider {
    position: relative;
    width: 3rem;
    height: 1.5rem;
    background: rgba(107, 114, 128, 0.3);
    border-radius: 9999px;
    margin-right: 0.75rem;
    transition: background-color 200ms;
    border: 1px solid rgba(107, 114, 128, 0.4);
  }

  .accessibility-toggle-slider::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 2px;
    transform: translateY(-50%);
    width: 1.25rem;
    height: 1.25rem;
    background: white;
    border-radius: 50%;
    transition: all 200ms;
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);
  }

  /* Dark mode specific overrides for toggle */
  :global(.dark) .accessibility-toggle-slider {
    background: rgba(156, 163, 175, 0.3);
    border-color: rgba(156, 163, 175, 0.5);
  }

  :global(.dark) .accessibility-toggle-slider::before {
    background: rgb(229, 231, 235);
  }

  .accessibility-toggle:checked + .accessibility-toggle-slider {
    background: var(--aw-color-primary);
    border-color: var(--aw-color-primary);
  }

  .accessibility-toggle:checked + .accessibility-toggle-slider::before {
    transform: translateX(1.5rem) translateY(-50%);
  }

  .accessibility-toggle-text {
    /* Font size scales via CustomStyles.astro */
  }

  /* TTS Button */
  .accessibility-tts-btn {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--aw-color-primary);
    border-radius: 0.375rem;
    background: var(--aw-color-primary);
    color: white;
    cursor: pointer;
    font-weight: 500;
    transition: all 200ms;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  .accessibility-tts-btn:hover:not(:disabled) {
    background: var(--aw-color-secondary);
    border-color: var(--aw-color-secondary);
  }

  .accessibility-tts-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .tts-btn-icon,
  .tts-loading-spinner {
    width: 20px;
    height: 20px;
    flex-shrink: 0;
  }

  /* Reset Button */
  .accessibility-reset-btn {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--aw-color-border);
    border-radius: 0.375rem;
    background: transparent;
    cursor: pointer;
    color: var(--aw-color-text-muted);
    transition: all 200ms;
  }

  .accessibility-reset-btn:hover {
    background: var(--aw-color-bg-hover);
    color: var(--aw-color-text);
    border-color: var(--aw-color-text-muted);
  }

  /* Prevent body scroll when panel open */
  :global(body.accessibility-panel-open) {
    overflow: hidden;
  }

  /* Reading Ruler Styles - Draggable Handle Approach */
  :global(.reading-ruler-container) {
    position: fixed;
    left: 0;
    width: 100vw;
    height: 1.5em; /* Default height - will be updated by JS */
    pointer-events: none; /* Allow clicks to pass through */
    z-index: 9998;
    display: flex;
    align-items: stretch;
  }

  :global(.reading-ruler-handle) {
    position: relative;
    width: 40px;
    flex-shrink: 0;
    background: rgba(147, 51, 234, 0.8); /* Purple accent */
    pointer-events: auto; /* Handle is interactive */
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none; /* Prevents scrolling when dragging handle */
    transition: background-color 0.2s ease;
  }

  :global(.reading-ruler-handle:hover) {
    background: rgba(147, 51, 234, 0.95);
  }

  :global(.reading-ruler-handle:active),
  :global(.reading-ruler-handle.dragging) {
    cursor: grabbing;
    background: rgba(126, 34, 206, 1);
  }

  :global(.reading-ruler-handle svg) {
    width: 20px;
    height: 20px;
    stroke: currentColor;
    fill: none;
  }

  :global(.reading-ruler-highlight) {
    flex: 1;
    background: transparent;
    border-bottom: 3px solid rgba(0, 0, 0, 0.8); /* Dark ruler line at bottom */
    pointer-events: none;
  }

  /* Dark mode adjustments - use light background highlight instead of line */
  :global(.dark) :global(.reading-ruler-highlight) {
    background: rgba(230, 230, 250, 0.2);
    border-bottom: none;
  }

  /* Add body padding when ruler is active to prevent content being covered */
  :global(body.reading-ruler-active) {
    padding-left: 40px;
  }

  /* Vertical line to demarcate ruler area - using ::before pseudo-element */
  :global(body.reading-ruler-active)::before {
    content: '';
    position: fixed;
    left: 40px;
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.3);
    z-index: 9997; /* Just below ruler handle */
    pointer-events: none;
  }

  /* Dark mode adjustment for vertical line */
  :global(.dark):global(body.reading-ruler-active)::before {
    background: rgba(255, 255, 255, 0.3);
  }

  /* Also pad the mobile accessibility panel when ruler is active (mobile only - it slides up from bottom) */
  @media (max-width: 767px) {
    :global(body.reading-ruler-active) .accessibility-panel {
      padding-left: 40px;
    }
  }

  /* Also pad the mobile menu (header when expanded) when ruler is active */
  /* Target at mobile viewport sizes where menu is visible */
  @media (max-width: 767px) {
    :global(body.reading-ruler-active) #header.expanded nav {
      padding-left: 40px !important;
    }

    :global(body.reading-ruler-active) #header.expanded nav ul {
      padding-left: 40px !important;
    }
  }

  /* Respect reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    :global(.reading-ruler-handle) {
      transition: none;
    }
  }
</style>

<script is:inline>
  (function () {
    // Local copy of AccessibilitySettings utilities (inline scripts can't use imports)
    const DEFAULT_SETTINGS = {
      font: 'sylexiad',
      theme: 'system',
      textSize: 'base',
      lineHeight: 'normal',
      readingRuler: false,
    };

    function getSettings() {
      if (typeof localStorage === 'undefined') return DEFAULT_SETTINGS;
      const stored = localStorage.getItem('accessibility-preferences');
      if (!stored) return DEFAULT_SETTINGS;
      try {
        return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };
      } catch {
        return DEFAULT_SETTINGS;
      }
    }

    function saveSettings(settings) {
      if (typeof localStorage === 'undefined') return;
      localStorage.setItem('accessibility-preferences', JSON.stringify(settings));
    }

    function resetSettings() {
      if (typeof localStorage === 'undefined') return DEFAULT_SETTINGS;
      localStorage.removeItem('accessibility-preferences');
      return DEFAULT_SETTINGS;
    }

    // Initialize settings from localStorage
    let currentSettings = getSettings();

    // Reading ruler state
    let readingRulerElement = null;
    let rulerHandleElement = null;
    let readingRulerEnabled = false;

    // Drag state
    let isDraggingRuler = false;
    let dragStartY = 0;
    let rulerStartTop = 0;

    // Main initialization function - called on initial load AND after each navigation
    function initializeAccessibilityPanel() {
      // Reload settings from localStorage (in case they changed)
      currentSettings = getSettings();

      // Apply settings on load
      applySettings(currentSettings);

      // Update UI to match loaded settings
      updateUI(currentSettings);
    }

    // === TOGGLE BUTTON EVENT DELEGATION ===
    // Handle clicks on any button with [data-accessibility-toggle]
    // This supports multiple toggle buttons (mobile + desktop) without duplicate IDs
    // Using event delegation on document level to persist across page navigations
    document.addEventListener('click', (e) => {
      const target = e.target.closest('[data-accessibility-toggle]');
      if (!target) return;

      const panel = document.getElementById('accessibility-panel');
      const allToggleButtons = document.querySelectorAll('[data-accessibility-toggle]');
      const isOpen = panel?.classList.contains('open');

      if (isOpen) {
        panel?.classList.remove('open');
        allToggleButtons.forEach((btn) => btn.setAttribute('aria-expanded', 'false'));
        document.body.classList.remove('accessibility-panel-open');
      } else {
        panel?.classList.add('open');
        allToggleButtons.forEach((btn) => btn.setAttribute('aria-expanded', 'true'));
        document.body.classList.add('accessibility-panel-open');
        setupFocusTrap();
      }
    });

    // === EVENT DELEGATION FOR ALL INTERACTIVE ELEMENTS ===
    // Use event delegation on document level to persist across Astro view transitions

    // Font selection - delegated
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target.matches && target.matches('input[name="font"]')) {
        currentSettings.font = target.value;
        saveSettings(currentSettings);
        applyFont(currentSettings.font);
      }
    });

    // Theme selection - delegated
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target.matches && target.matches('input[name="theme"]')) {
        currentSettings.theme = target.value;
        saveSettings(currentSettings);
        applyTheme(currentSettings.theme);
      }
    });

    // Text size buttons - delegated
    document.addEventListener('click', (e) => {
      const button = e.target.closest('.accessibility-size-btn');
      if (!button) return;

      const size = button.dataset.textSize;
      if (!size) return;

      currentSettings.textSize = size;
      saveSettings(currentSettings);

      // Update active state
      document.querySelectorAll('.accessibility-size-btn').forEach((b) => {
        b.classList.remove('active');
        b.setAttribute('aria-pressed', 'false');
      });
      button.classList.add('active');
      button.setAttribute('aria-pressed', 'true');

      // Update label
      const labels = {
        xs: 'Extra Small',
        sm: 'Small',
        base: 'Normal',
        lg: 'Large',
        xl: 'Extra Large',
      };
      const label = document.getElementById('text-size-label');
      if (label) label.textContent = labels[size] || 'Normal';

      // Apply the text size
      applyTextSize(size);

      // Update ruler height if ruler is enabled
      if (readingRulerEnabled) {
        updateRulerHeight();
      }
    });

    // Line height - delegated
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target.matches && target.matches('input[name="lineHeight"]')) {
        currentSettings.lineHeight = target.value;
        saveSettings(currentSettings);
        applyLineHeight(currentSettings.lineHeight);

        // Update ruler height if ruler is enabled
        if (readingRulerEnabled) {
          updateRulerHeight();
        }
      }
    });

    // Reading ruler - delegated
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target.id === 'reading-ruler') {
        currentSettings.readingRuler = target.checked;
        saveSettings(currentSettings);
        applyReadingRuler(currentSettings.readingRuler); // Actually apply the change
      }
    });

    // Reset button - delegated
    document.addEventListener('click', (e) => {
      const target = e.target.closest('#reset-settings');
      if (!target) return;

      currentSettings = resetSettings();
      applySettings(currentSettings);

      // Update UI to reflect reset
      location.reload(); // Simple way to reset all UI elements
    });

    // Close button - delegated
    document.addEventListener('click', (e) => {
      const target = e.target.closest('#accessibility-close');
      if (!target) return;
      closePanel();
    });

    // Close on backdrop click - delegated
    document.addEventListener('click', (e) => {
      const target = e.target.closest('#accessibility-backdrop');
      if (!target) return;
      closePanel();
    });

    // Close on Escape key - using event delegation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const panel = document.getElementById('accessibility-panel');
        if (panel?.classList.contains('open')) {
          closePanel();
        }
      }
    });

    // Keyboard shortcut: Ctrl+Shift+A (or Cmd+Shift+A on Mac) - using event delegation
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'A') {
        e.preventDefault();
        const panel = document.getElementById('accessibility-panel');
        const allToggleButtons = document.querySelectorAll('[data-accessibility-toggle]');

        if (panel?.classList.contains('open')) {
          closePanel();
        } else {
          panel?.classList.add('open');
          allToggleButtons.forEach((btn) => btn.setAttribute('aria-expanded', 'true'));
          document.body.classList.add('accessibility-panel-open');
          setupFocusTrap();
        }
      }
    });

    // Focus trap implementation
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    let firstFocusableElement = null;
    let lastFocusableElement = null;

    function setupFocusTrap() {
      const panel = document.getElementById('accessibility-panel');
      if (!panel) return;

      const focusableContent = panel.querySelectorAll(focusableElements);
      firstFocusableElement = focusableContent[0];
      lastFocusableElement = focusableContent[focusableContent.length - 1];

      // Focus first element when panel opens
      if (firstFocusableElement) firstFocusableElement.focus();
    }

    // Trap focus within panel - using event delegation
    document.addEventListener('keydown', (e) => {
      const panel = document.getElementById('accessibility-panel');
      if (!panel || !panel.classList.contains('open')) return;

      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift+Tab: going backwards
          if (document.activeElement === firstFocusableElement) {
            e.preventDefault();
            if (lastFocusableElement) lastFocusableElement.focus();
          }
        } else {
          // Tab: going forwards
          if (document.activeElement === lastFocusableElement) {
            e.preventDefault();
            if (firstFocusableElement) firstFocusableElement.focus();
          }
        }
      }
    });

    function closePanel() {
      const panelElement = document.getElementById('accessibility-panel');
      const allToggleButtons = document.querySelectorAll('[data-accessibility-toggle]');

      if (panelElement) panelElement.classList.remove('open');
      allToggleButtons.forEach((btn) => btn.setAttribute('aria-expanded', 'false'));
      document.body.classList.remove('accessibility-panel-open');
    }

    function updateUI(settings) {
      // Update font radio buttons
      const fontRadio = document.querySelector(`input[name="font"][value="${settings.font}"]`);
      if (fontRadio) fontRadio.checked = true;

      // Update theme radio buttons
      const themeRadio = document.querySelector(`input[name="theme"][value="${settings.theme}"]`);
      if (themeRadio) themeRadio.checked = true;

      // Update text size buttons
      document.querySelectorAll('.accessibility-size-btn').forEach((btn) => {
        const button = btn;
        const size = button.dataset.textSize;
        if (size === settings.textSize) {
          button.classList.add('active');
          button.setAttribute('aria-pressed', 'true');
        } else {
          button.classList.remove('active');
          button.setAttribute('aria-pressed', 'false');
        }
      });

      // Update text size label
      const labels = {
        xs: 'Extra Small',
        sm: 'Small',
        base: 'Normal',
        lg: 'Large',
        xl: 'Extra Large',
      };
      const label = document.getElementById('text-size-label');
      if (label) label.textContent = labels[settings.textSize] || 'Normal';

      // Update line height radio buttons
      const lineHeightRadio = document.querySelector(`input[name="lineHeight"][value="${settings.lineHeight}"]`);
      if (lineHeightRadio) lineHeightRadio.checked = true;

      // Update reading ruler checkbox
      const rulerCheckbox = document.getElementById('reading-ruler');
      if (rulerCheckbox) rulerCheckbox.checked = settings.readingRuler;
    }

    function applySettings(settings) {
      applyFont(settings.font);
      applyTheme(settings.theme);
      applyTextSize(settings.textSize);
      applyLineHeight(settings.lineHeight);
      applyReadingRuler(settings.readingRuler); // Apply reading ruler
    }

    function applyFont(font) {
      // Copy existing ToggleFont logic
      const fonts = {
        sylexiad: 'Sylexiad Sans Medium, ui-sans-serif, system-ui, -apple-system',
        opendyslexic: 'OpenDyslexic3, ui-sans-serif, system-ui, -apple-system',
        fast: 'Fast Sans, ui-sans-serif, system-ui, -apple-system',
      };

      document.documentElement.style.setProperty('--aw-font-sans', fonts[font]);
    }

    function applyTheme(theme) {
      // Copy existing ToggleTheme logic
      if (theme === 'system') {
        localStorage.removeItem('theme');
        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        document.documentElement.classList.toggle('dark', systemTheme === 'dark');
      } else {
        localStorage.setItem('theme', theme);
        document.documentElement.classList.toggle('dark', theme === 'dark');
      }
    }

    function applyTextSize(size) {
      // Remove all text-size-* classes from body
      document.body.classList.remove('text-size-xs', 'text-size-sm', 'text-size-base', 'text-size-lg', 'text-size-xl');

      // Add new text-size class
      if (size && size !== 'base') {
        document.body.classList.add(`text-size-${size}`);
      }
      // Note: base is default (no class needed, uses :root value)
    }

    function applyLineHeight(lineHeight) {
      const body = document.body;

      // Remove all line height classes
      body.classList.remove('line-height-compact', 'line-height-normal', 'line-height-relaxed');

      // Add selected line height class
      if (lineHeight && lineHeight !== 'normal') {
        body.classList.add(`line-height-${lineHeight}`);
      }
      // Note: normal is default (no class needed, uses :root value)
    }

    /**
     * Create reading ruler with draggable handle
     */
    function createReadingRuler() {
      if (readingRulerElement) return; // Already exists

      // Create container
      const container = document.createElement('div');
      container.className = 'reading-ruler-container';

      // Create draggable handle
      const handle = document.createElement('div');
      handle.className = 'reading-ruler-handle';
      handle.setAttribute('aria-label', 'Drag to reposition reading ruler');
      handle.setAttribute('role', 'slider');
      handle.setAttribute('aria-orientation', 'vertical');
      handle.setAttribute('tabindex', '0');

      // Add Tabler icon (arrows-move-vertical)
      handle.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 7l0 14"></path>
          <path d="M9 18l3 3l3 -3"></path>
          <path d="M9 6l3 -3l3 3"></path>
        </svg>
      `;

      // Create highlight bar
      const highlight = document.createElement('div');
      highlight.className = 'reading-ruler-highlight';

      // Assemble
      container.appendChild(handle);
      container.appendChild(highlight);
      document.body.appendChild(container);

      // Store references
      readingRulerElement = container;
      rulerHandleElement = handle;

      // Set initial height based on current line height and text size settings
      updateRulerHeight();

      // Position in middle of viewport initially
      const initialTop = (window.innerHeight - parseFloat(container.style.height || container.offsetHeight)) / 2;
      positionRuler(initialTop);

      // Setup drag handlers
      setupDragHandlers();
    }

    /**
     * Remove reading ruler element
     */
    function removeReadingRuler() {
      if (readingRulerElement) {
        readingRulerElement.remove();
        readingRulerElement = null;
        rulerHandleElement = null;
      }
    }

    /**
     * Get current text size scale factor
     */
    function getTextSizeScale() {
      const body = document.body;
      if (body.classList.contains('text-size-xs')) return 0.875;
      if (body.classList.contains('text-size-sm')) return 0.9375;
      if (body.classList.contains('text-size-lg')) return 1.125;
      if (body.classList.contains('text-size-xl')) return 1.25;
      return 1; // base
    }

    /**
     * Update ruler height based on line height and text size settings
     */
    function updateRulerHeight() {
      if (!readingRulerElement) return;

      // Get current line height scale from body class
      const body = document.body;
      let lineHeightScale = 1.5; // Default (normal)

      if (body.classList.contains('line-height-compact')) {
        lineHeightScale = 1.2;
      } else if (body.classList.contains('line-height-relaxed')) {
        lineHeightScale = 2.0;
      }

      // Get current text size scale
      const textSizeScale = getTextSizeScale();

      // Calculate final height: base font size (16px) × text size scale × line height scale × 1.2 (20% larger)
      const heightInEm = textSizeScale * lineHeightScale * 1.2;

      // Set the height
      readingRulerElement.style.height = `${heightInEm}em`;
    }

    /**
     * Position ruler at specific Y coordinate (viewport-relative)
     */
    function positionRuler(topPosition) {
      if (!readingRulerElement) return;

      // Get ruler height in pixels
      const rulerHeight = readingRulerElement.offsetHeight;

      // Constrain to viewport
      const minY = 0;
      const maxY = window.innerHeight - rulerHeight;
      const constrainedTop = Math.max(minY, Math.min(maxY, topPosition));

      // Update position
      readingRulerElement.style.top = `${constrainedTop}px`;
    }

    /**
     * Setup drag handlers for ruler handle
     */
    function setupDragHandlers() {
      if (!rulerHandleElement) return;

      // Mouse drag start
      const handleMouseDown = (e) => {
        isDraggingRuler = true;
        dragStartY = e.clientY;
        rulerStartTop = readingRulerElement.offsetTop;
        rulerHandleElement.classList.add('dragging');
        e.preventDefault(); // Prevent text selection
      };

      // Touch drag start
      const handleTouchStart = (e) => {
        if (e.touches.length !== 1) return;
        isDraggingRuler = true;
        dragStartY = e.touches[0].clientY;
        rulerStartTop = readingRulerElement.offsetTop;
        rulerHandleElement.classList.add('dragging');
        e.preventDefault(); // Prevent text selection and scrolling
      };

      // Mouse drag move
      const handleMouseMove = (e) => {
        if (!isDraggingRuler) return;
        const deltaY = e.clientY - dragStartY;
        const newTop = rulerStartTop + deltaY;
        positionRuler(newTop);
      };

      // Touch drag move
      const handleTouchMove = (e) => {
        if (!isDraggingRuler || e.touches.length !== 1) return;
        const deltaY = e.touches[0].clientY - dragStartY;
        const newTop = rulerStartTop + deltaY;
        positionRuler(newTop);
        e.preventDefault(); // Prevent scrolling while dragging
      };

      // Mouse drag end
      const handleMouseUp = () => {
        if (!isDraggingRuler) return;
        isDraggingRuler = false;
        rulerHandleElement?.classList.remove('dragging');
      };

      // Touch drag end
      const handleTouchEnd = () => {
        if (!isDraggingRuler) return;
        isDraggingRuler = false;
        rulerHandleElement?.classList.remove('dragging');
      };

      // Keyboard support for accessibility
      const handleKeyDown = (e) => {
        if (!rulerHandleElement) return;

        const step = 10; // pixels to move per keypress
        let newTop = readingRulerElement.offsetTop;

        if (e.key === 'ArrowUp') {
          newTop -= step;
          positionRuler(newTop);
          e.preventDefault();
        } else if (e.key === 'ArrowDown') {
          newTop += step;
          positionRuler(newTop);
          e.preventDefault();
        }
      };

      // Attach event listeners
      rulerHandleElement.addEventListener('mousedown', handleMouseDown);
      rulerHandleElement.addEventListener('touchstart', handleTouchStart, { passive: false });
      rulerHandleElement.addEventListener('keydown', handleKeyDown);

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('touchend', handleTouchEnd);

      // Store handler references for cleanup
      rulerHandleElement._handlers = {
        mousedown: handleMouseDown,
        touchstart: handleTouchStart,
        keydown: handleKeyDown,
        mousemove: handleMouseMove,
        touchmove: handleTouchMove,
        mouseup: handleMouseUp,
        touchend: handleTouchEnd,
      };
    }

    /**
     * Remove drag handlers
     */
    function removeDragHandlers() {
      if (!rulerHandleElement || !rulerHandleElement._handlers) return;

      const handlers = rulerHandleElement._handlers;

      rulerHandleElement.removeEventListener('mousedown', handlers.mousedown);
      rulerHandleElement.removeEventListener('touchstart', handlers.touchstart);
      rulerHandleElement.removeEventListener('keydown', handlers.keydown);

      document.removeEventListener('mousemove', handlers.mousemove);
      document.removeEventListener('touchmove', handlers.touchmove);
      document.removeEventListener('mouseup', handlers.mouseup);
      document.removeEventListener('touchend', handlers.touchend);

      delete rulerHandleElement._handlers;
    }

    /**
     * Enable reading ruler
     */
    function enableReadingRuler() {
      if (readingRulerEnabled) return; // Already enabled
      createReadingRuler();
      document.body.classList.add('reading-ruler-active');

      // Add padding to mobile nav menu items directly via inline styles
      // This ensures the padding is applied even when Tailwind utilities have higher specificity
      const mobileNavs = document.querySelectorAll('#header nav');
      mobileNavs.forEach((nav) => {
        nav.style.paddingLeft = '40px';
      });

      readingRulerEnabled = true;
    }

    /**
     * Disable reading ruler
     */
    function disableReadingRuler() {
      if (!readingRulerEnabled) return; // Already disabled

      // Remove drag handlers
      removeDragHandlers();

      // Remove ruler element
      removeReadingRuler();

      // Remove body padding
      document.body.classList.remove('reading-ruler-active');

      // Remove inline padding from mobile nav menu items
      const mobileNavs = document.querySelectorAll('#header nav');
      mobileNavs.forEach((nav) => {
        nav.style.paddingLeft = '';
      });

      // Reset drag state
      isDraggingRuler = false;
      dragStartY = 0;
      rulerStartTop = 0;

      readingRulerEnabled = false;
    }

    /**
     * Apply reading ruler setting
     */
    function applyReadingRuler(enabled) {
      if (enabled) {
        enableReadingRuler();
      } else {
        disableReadingRuler();
      }
    }

    // === INITIAL LOAD ===
    // Run on initial page load
    initializeAccessibilityPanel();

    // === ASTRO VIEW TRANSITIONS ===
    // Cleanup reading ruler during page transitions
    document.addEventListener('astro:before-swap', () => {
      // Clean up ruler element and event listeners during page transition
      if (readingRulerEnabled) {
        // Remove drag handlers
        removeDragHandlers();
        // Remove ruler element
        removeReadingRuler();
        // Reset drag state
        isDraggingRuler = false;
        dragStartY = 0;
        rulerStartTop = 0;
        // Reset flag so it can be recreated on next page if setting is enabled
        readingRulerEnabled = false;
      }
    });

    // Re-initialize after each client-side navigation (Astro View Transitions)
    document.addEventListener('astro:page-load', () => {
      initializeAccessibilityPanel();
    });
  })();
</script>
